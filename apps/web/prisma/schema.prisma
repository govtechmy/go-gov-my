// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_URL")
  extensions   = [pgcrypto(map: "pgcrypto", schema: "public")]
  relationMode = "foreignKeys"
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]

  // Use engine type "binary" for esbuild to bundle prisma correctly when
  // building the outbox kafka consumer
  engineType      = "binary"
}

model Agency {
  code  String  @id
  logo  String?
  names Json

  members User[]
}

model User {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  agencyCode    String    @default("govtech")
  role          UserRole  @default(staff)

  agency Agency @relation(fields: [agencyCode], references: [code])

  accounts   Account[]
  sessions   Session[]
  projects   ProjectUsers[]
  links      Link[]
  tokens     Token[]
  createdAt  DateTime       @default(now()) @db.Timestamptz
  subscribed Boolean        @default(true)

  @@index([agencyCode])
}

enum UserRole {
  staff
  super_admin
}

model Account {
  id                       String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId                   String  @db.Uuid
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String? @db.Text
  refresh_token_expires_in Int?
  access_token             String? @db.Text
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String? @db.Text
  session_state            String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @map("session_token") @db.Text
  userId       String   @db.Uuid
  expires      DateTime @default(now()) @db.Timestamptz
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}

model Token {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name       String
  hashedKey  String    @unique
  partialKey String
  expires    DateTime?
  lastUsed   DateTime?
  createdAt  DateTime  @default(now()) @db.Timestamptz
  updatedAt  DateTime  @updatedAt
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String    @db.Uuid

  @@index([userId])
}

model Project {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String
  slug        String    @unique
  logo        String?
  agencyCode  String    @default("govtech")


  plan              String @default("business")
  billingCycleStart Int // day of the month when the billing cycle starts
  usage             Int    @default(0)
  usageLimit        Int    @default(1000)
  aiUsage           Int    @default(0)
  aiLimit           Int    @default(10)
  linksUsage        Int    @default(0)
  linksLimit        Int    @default(25)
  tagsLimit         Int    @default(5)

  users      ProjectUsers[]
  invites    ProjectInvite[]
  sentEmails SentEmail[]
  links      Link[]
  tags       Tag[]

  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt

  inviteCode     String?          @unique
  defaultDomains DefaultDomains[]
}

model ProjectInvite {
  email     String
  expires   DateTime?
  project   Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String    @db.Uuid
  createdAt DateTime  @default(now()) @db.Timestamptz

  @@id([email, projectId])
  @@index([projectId])
}

model DefaultDomains {
  id          String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  dubsh       Boolean @default(true)
  chatgpt     Boolean @default(true)
  sptifi      Boolean @default(true)
  gitnew      Boolean @default(true)
  amznid      Boolean @default(true)
  loooooooong Boolean @default(false)
  projectId   String  @db.Uuid
  project     Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
}

enum Role {
  owner
  member
}

model ProjectUsers {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  role      Role     @default(member)
  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @db.Uuid
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String   @db.Uuid

  @@unique([userId, projectId])
  @@index([projectId])
}

model SentEmail {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  type      String
  createdAt DateTime @default(now()) @db.Timestamptz
  project   Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String?  @db.Uuid

  @@index([projectId])
}

model Link {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  domain     String // domain of the link (e.g. dub.sh) – also stored on Redis
  key        String // key of the link (e.g. /github) – also stored on Redis
  url        String // @db.LongText // target url (e.g. https://github.com/dubinc/dub) – also stored on Redis
  archived   Boolean   @default(false) // whether the link is archived or not
  expiresAt  DateTime? // when the link expires – stored on Redis via ttl
  expiredUrl String? // @db.LongText // URL to redirect the user to when the link is expired
  password   String? // password to access the link
  externalId String?
  banned     Boolean   @default(false)

  trackConversion Boolean @default(false) // whether to track conversions or not

  proxy       Boolean @default(false) // Proxy to use custom OG tags (stored on redis) – if false, will use OG tags from target url
  title       String? // OG title for the link (e.g. Dub.co - Open-Source Link Management Infrastructure)
  description String? @db.VarChar(280) // OG description for the link (e.g. An open-source link management tool for modern marketing teams to create, share, and track short links.)
  image       String? // @db.LongText // OG image for the link (e.g. https://d.to/og)

  // UTM parameters
  utm_source   String? // UTM source for the link (e.g. youtube.com)
  utm_medium   String? // UTM medium for the link (e.g. social)
  utm_campaign String? // UTM campaign for the link (e.g. summer-sale)
  utm_term     String? // UTM term for the link (e.g. dub)
  utm_content  String? // UTM content for the link (e.g. description)

  // Custom device targeting
  ios     String? // @db.LongText // custom link for iOS devices
  android String? // @db.LongText // custom link for Android devices
  geo     Json?   @db.Json // custom link for specific countries

  // User who created the link
  user   User?   @relation(fields: [userId], references: [id])
  userId String? @db.Uuid

  // Project that the link belongs to
  project       Project @relation(fields: [projectId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  projectId     String  @db.Uuid

  publicStats Boolean   @default(false) // whether to show public stats or not
  clicks      Int       @default(0) // number of clicks
  lastClicked DateTime? // when the link was last clicked
  createdAt   DateTime  @default(now()) @db.Timestamptz
  updatedAt   DateTime  @updatedAt

  // Link tags
  tags LinkTag[]

  // Link history
  history LinkHistory[]

  // Comments on the particular shortlink
  comments String? //@db.LongText

  // TODO: might wanna add indices for utm_source, utm_medium, utm_campaign
  // @@fulltext([key, url])

  @@unique([domain, key])
  @@unique([projectId, externalId])
  @@index(projectId)
  @@index(domain)
  @@index(trackConversion)
  @@index(proxy)
  @@index(password)
  @@index(createdAt(sort: Desc))
  @@index(clicks(sort: Desc))
  @@index(lastClicked)
  @@index(userId)
}

model WebhookOutbox {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  host              String
  payload           Json
  createdAt         DateTime @default(now()) @db.Timestamptz
  action            String
  headers           Json
  partitionKey      String
  encryptedSecrets  String?
}

model LinkHistory {
  id                String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  type              LinkHistoryType
  committedByUserId String?         @db.Uuid // The user who created/updated the link
  linkId            String          @db.Uuid
  link              Link            @relation(fields: [linkId], references: [id], onDelete: Cascade)
  timestamp         DateTime        @db.Timestamptz

  // Everything below are the columns we want to track from Link model
  domain     String
  key        String
  url        String
  archived   Boolean
  expiresAt  DateTime?
  expiredUrl String?
  password   String?
  externalId String?

  trackConversion Boolean
  publicStats     Boolean

  proxy       Boolean
  title       String?
  description String? @db.VarChar(280)
  image       String?

  ios     String?
  android String?
  geo     Json?   @db.Json

  @@index([linkId])
}

enum LinkHistoryType {
  create
  update
}

model Tag {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String
  color     String    @default("blue")
  createdAt DateTime  @default(now()) @db.Timestamptz
  updatedAt DateTime  @updatedAt
  project   Project   @relation(fields: [projectId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  projectId String    @db.Uuid
  links     LinkTag[]

  @@unique([name, projectId])
  @@index(projectId)
}

model LinkTag {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt
  link      Link     @relation(fields: [linkId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  linkId    String   @db.Uuid
  tag       Tag      @relation(fields: [tagId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  tagId     String   @db.Uuid

  @@unique([linkId, tagId])
  @@index(linkId)
  @@index(tagId)
}

model Analytics {
  id                    String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  linkId                String
  from                  DateTime
  to                    DateTime
  aggregatedDate        DateTime   @db.Date
  metadata              Json       @db.Json
  createdAt             DateTime   @default(now()) @db.Timestamptz
  updatedAt             DateTime   @updatedAt
}

model IdempotentResource {
  idempotencyKey     String @id
  hashedPayload      String
  createdAt          DateTime   @default(now()) @db.Timestamptz
}